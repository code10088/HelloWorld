#region tcp
// using System;
// using System.Net;
// using System.Net.Sockets;
// using System.Threading;
// using System.Threading.Tasks;

// class Program
// {
//    static async Task Main(string[] args)
//    {
//        int port = 8088; // 端口号可根据你的 STCP 配置修改
//        var listener = new TcpListener(IPAddress.Any, port);
//        listener.Start();
//        Console.WriteLine($"TCP服务器已启动，监听端口 {port}");

//        while (true)
//        {
//            var client = await listener.AcceptTcpClientAsync();
//            Console.WriteLine("客户端已连接");
//            _ = HandleClient(client);
//        }
//    }

//    static async Task HandleClient(TcpClient client)
//    {
//        using (client)
//        using (var stream = client.GetStream())
//        {
//            byte[] headBuffer = new byte[4];
//            while (true)
//            {
//                // 读取包头（4字节，表示包体长度）
//                int headRead = 0;
//                while (headRead < 4)
//                {
//                    int n = await stream.ReadAsync(headBuffer, headRead, 4 - headRead);
//                    if (n == 0) return; // 断开
//                    headRead += n;
//                }
//                int bodyLength = BitConverter.ToInt32(headBuffer, 0);
//                if (bodyLength < 0 || bodyLength > 0x2800)
//                {
//                    Console.WriteLine($"非法包长: {bodyLength}");
//                    return;
//                }

//                // 读取包体
//                byte[] bodyBuffer = new byte[bodyLength];
//                int bodyRead = 0;
//                while (bodyRead < bodyLength)
//                {
//                    int n = await stream.ReadAsync(bodyBuffer, bodyRead, bodyLength - bodyRead);
//                    if (n == 0) return;
//                    bodyRead += n;
//                }

//                Console.WriteLine($"收到包，长度: {bodyLength}");

//                // 这里可以根据需要处理包体内容
//                // 示例：原样回显
//                await stream.WriteAsync(headBuffer, 0, 4);
//                bodyBuffer = BitConverter.GetBytes(10001);
//                await stream.WriteAsync(bodyBuffer, 0, bodyLength);
//            }
//        }
//    }
// }
#endregion

#region kcp
//using System;
//using System.Buffers;
//using System.Buffers.Binary;
//using System.Drawing;
//using System.Net;
//using System.Net.Sockets;
//using System.Net.Sockets.Kcp;
//using System.Threading.Tasks;
//using static System.Runtime.InteropServices.JavaScript.JSType;

//class KcpServer : IKcpCallback
//{
//    private readonly UdpClient udp;
//    private readonly IPEndPoint listenEndPoint;
//    private PoolSegManager.Kcp kcp;
//    private IPEndPoint remoteEndPoint;
//    private uint conv = 0;

//    public KcpServer(int port)
//    {
//        listenEndPoint = new IPEndPoint(IPAddress.Any, port);
//        udp = new UdpClient(listenEndPoint);
//        kcp = new PoolSegManager.Kcp(conv, this);
//        StartReceive();
//    }

//    public void Output(IMemoryOwner<byte> buffer, int avalidLength)
//    {
//        if (remoteEndPoint != null)
//        {
//            var data = buffer.Memory.Span.Slice(0, avalidLength).ToArray();
//            Console.WriteLine(data.Length);
//            udp.SendAsync(data, data.Length, remoteEndPoint);
//        }
//        buffer.Dispose();
//    }

//    private async void StartReceive()
//    {
//        while (true)
//        {
//            kcp.Update(DateTime.UtcNow);
//            var result = await udp.ReceiveAsync();
//            remoteEndPoint = result.RemoteEndPoint;
//            var id = BitConverter.ToUInt16(result.Buffer, 4);
//            if (id == 0)
//            {
//                byte[] a = new byte[6];
//                BinaryPrimitives.WriteUInt16LittleEndian(a.AsSpan(0, 2), 10000);
//                BinaryPrimitives.WriteUInt32LittleEndian(a.AsSpan(2, 4), ++conv);
//                kcp = new PoolSegManager.Kcp(conv, this);
//                udp.Send(a, a.Length, remoteEndPoint);
//                continue;
//            }
//            kcp.Input(result.Buffer);
//            // 这里可以根据需要处理收到的数据
//            // 例如：自动回显
//            var (recvBuffer, recvLen) = kcp.TryRecv();
//            if (recvBuffer != null && recvLen > 0)
//            {
//                // 回显收到的数据
//                byte[] a = BitConverter.GetBytes((ushort)10001);
//                kcp.Send(a);
//                recvBuffer.Dispose();
//            }
//        }
//    }
//}

//class Program
//{
//    static void Main(string[] args)
//    {
//        Console.WriteLine("KCP服务器启动，监听端口: 8088");
//        var server = new KcpServer(8088);
//        Console.ReadLine();
//    }
//}
#endregion

#region websocket
// using System;
// using WebSocketSharp;
// using WebSocketSharp.Server;
// using ErrorEventArgs = WebSocketSharp.ErrorEventArgs;

// namespace SimpleWebSocketServer
// {
//     // 自定义一个 WebSocket 服务行为类，处理客户端的连接、消息等
//     public class MyWebSocketService : WebSocketBehavior
//     {
//         // 当客户端连接到服务时触发
//         protected override void OnOpen()
//         {
//             Console.WriteLine($"[Server] 客户端已连接: ");

//             // 可选：向刚连接的客户端发送欢迎消息
//             Send("欢迎连接到 WebSocket 服务器！");
//         }

//         // 当服务器收到来自客户端的消息时触发
//         protected override void OnMessage(MessageEventArgs e)
//         {
//             Console.WriteLine($"[Server] 收到来自  的消息: {e.Data}");

//             // 简单回显：将收到的消息原样发回给客户端
//             var a= BitConverter.GetBytes((ushort)10001);
//             Send(a);
//         }

//         // 当连接发生错误时触发
//         protected override void OnError(ErrorEventArgs e)
//         {
//             Console.WriteLine($"[Server] 发生错误: {e.Message}");
//         }

//         // 当客户端断开连接时触发
//         protected override void OnClose(CloseEventArgs e)
//         {
//             Console.WriteLine($"[Server] 客户端断开连接: , 原因: {e.Reason}");
//         }
//     }

//     class Program
//     {
//         static void Main(string[] args)
//         {
//             // 创建一个 WebSocket 服务器，监听 ws://localhost:8088/
//             var wssv = new WebSocketServer("ws://192.168.7.148:8088/"); // 你也可以使用 wss://localhost:8088/ 来启用 SSL

//             // 可选：设置日志级别（调试用）
//             wssv.Log.Level = LogLevel.Debug;

//             // 添加一个 WebSocket 服务，路径为 "/ws"，使用我们上面定义的 MyWebSocketService 类来处理
//             wssv.AddWebSocketService<MyWebSocketService>("/client");

//             // 启动服务器
//             wssv.Start();
//             Console.WriteLine("WebSocket 服务器已启动，监听 ws://localhost:8088/client");
//             Console.WriteLine("按任意键停止服务器...");
//             Console.ReadKey(true);

//             // 停止服务器
//             wssv.Stop();
//             Console.WriteLine("服务器已停止。");
//         }
//     }
// }
#endregion